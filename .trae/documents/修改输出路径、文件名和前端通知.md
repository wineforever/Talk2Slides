# 修改输出路径、文件名和前端通知

## 问题分析

用户提出了三个需求：
1. **输出路径问题**：当前视频生成在 `.\Talk2Slides\backend\output\XXX` 文件夹下，希望改为 `.\Talk2Slides\output`（项目根目录）
2. **文件名问题**：当前固定为 `output.mp4`，希望添加日期时间信息
3. **前端通知问题**：处理完成后网页不要一直弹处理成功的提示信息，弹一次就行，并配上提示音效

## 解决方案

### 第一阶段：修改输出路径配置

#### 1.1 修改 `config.py` 中的 OUTPUT_DIR
- **当前**：`OUTPUT_DIR: Path = BASE_DIR / "output"`（指向 `backend/output`）
- **目标**：改为项目根目录下的 `output` 文件夹
- **修改方案**：
  ```python
  OUTPUT_DIR: Path = BASE_DIR.parent / "output"
  ```
- **验证**：确保 `BASE_DIR.parent` 正确指向 `Talk2Slides` 目录

#### 1.2 验证目录创建
- 检查 `main.py` 中的 `lifespan` 函数，确保 `os.makedirs(settings.OUTPUT_DIR, exist_ok=True)` 能正确创建新目录
- 测试新路径权限：确保应用有写入权限

### 第二阶段：修改文件名生成逻辑

#### 2.1 修改 `endpoints.py` 中的文件名生成
- **当前**：固定文件名 `output.mp4`
- **目标**：包含日期时间信息的动态文件名，格式：`video_YYYYMMDD_HHMMSS.mp4`
- **修改方案**：
  ```python
  from datetime import datetime
  
  # 在 process_video_generation 函数中
  timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
  filename = f"video_{timestamp}.mp4"
  output_video_path = settings.OUTPUT_DIR / task_id / filename
  ```

#### 2.2 修改 `get_task_result` 函数
- **当前**：硬编码 `filename="generated_video.mp4"`
- **目标**：从存储的视频路径中提取实际文件名
- **修改方案**：
  ```python
  filename = os.path.basename(video_path)
  return FileResponse(
      video_path,
      media_type="video/mp4",
      filename=filename
  )
  ```

#### 2.3 更新任务结果存储
- 确保 `task.result["video_path"]` 存储完整的文件路径
- 当前已正确存储，无需修改

### 第三阶段：修改前端文件名下载

#### 3.1 修改下载链接的文件名
- **当前**：`download="generated_video.mp4"`（硬编码）
- **目标**：使用实际生成的文件名
- **修改方案**：
  ```html
  <!-- 方案1：从URL提取文件名 -->
  <a :href="resultVideoUrl" :download="getVideoFileName(resultVideoUrl)">
  
  <!-- 方案2：API返回文件名 -->
  <!-- 需要修改后端API返回文件名信息 -->
  ```

#### 3.2 实现文件名提取函数
```javascript
const getVideoFileName = (url) => {
    // 从URL中提取文件名
    const parts = url.split('/');
    return parts[parts.length - 1] || 'generated_video.mp4';
};
```

### 第四阶段：修改前端通知和音效

#### 4.1 防止重复通知
- **当前**：在状态轮询中，当 `status.state === 'completed'` 时显示 `ElMessage.success`
- **问题**：理论上只显示一次，但添加保险机制
- **修改方案**：
  ```javascript
  let hasShownSuccess = false;
  
  // 在轮询逻辑中
  if (status.state === 'completed' && !hasShownSuccess) {
      hasShownSuccess = true;
      clearInterval(pollInterval);
      progress.value = 100;
      progressText.value = '处理完成！';
      processing.value = false;
      
      // 获取结果视频URL
      const resultResponse = await axios.get(`/api/task/${taskId.value}/result`);
      resultVideoUrl.value = resultResponse.data.video_url;
      
      // 显示成功通知
      ElMessage.success('视频生成成功！');
      
      // 播放提示音效
      playNotificationSound();
  }
  ```

#### 4.2 添加提示音效
- **方案1**：使用内置的 `AudioContext` 生成简短提示音
- **方案2**：使用外部音效文件（需要托管）
- **方案3**：使用 base64 编码的简单音效
- **实现方案**（使用方案1）：
  ```javascript
  const playNotificationSound = () => {
      try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          oscillator.frequency.value = 800;
          oscillator.type = 'sine';
          
          gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
          
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.5);
      } catch (error) {
          console.log('音效播放失败:', error);
          // 静默失败，不影响主要功能
      }
  };
  ```

#### 4.3 备选方案：使用 HTML5 Audio（更简单）
```javascript
const playNotificationSound = () => {
    try {
        // 创建简单的提示音
        const audio = new Audio();
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = 800;
        gainNode.gain.value = 0.3;
        
        oscillator.start();
        setTimeout(() => oscillator.stop(), 300);
    } catch (e) {
        // 静默失败
    }
};
```

## 实施步骤

### 步骤1：修改后端配置（5分钟）
1. 修改 `backend/app/core/config.py` 中的 `OUTPUT_DIR`
2. 验证路径计算是否正确

### 步骤2：修改后端文件名生成（10分钟）
1. 在 `endpoints.py` 中添加 `datetime` 导入
2. 修改 `process_video_generation` 函数中的文件名生成逻辑
3. 修改 `get_task_result` 函数中的 `FileResponse` 文件名
4. 测试修改后的逻辑

### 步骤3：修改前端文件下载（10分钟）
1. 在 `frontend/index.html` 中添加文件名提取函数
2. 修改下载链接的 `download` 属性
3. 测试文件下载功能

### 步骤4：修改前端通知和音效（15分钟）
1. 添加 `hasShownSuccess` 标志防止重复通知
2. 实现 `playNotificationSound` 函数
3. 在成功时调用音效函数
4. 测试通知和音效功能

### 步骤5：全面测试（10分钟）
1. 上传文件测试完整流程
2. 验证输出路径是否正确
3. 验证文件名是否包含日期时间
4. 验证通知只显示一次并有音效
5. 验证文件下载功能正常

## 预期结果

### 修改后效果
1. **输出路径**：视频文件将生成在 `Talk2Slides/output/{task_id}/` 目录下
2. **文件名**：格式为 `video_20250208_143022.mp4`（包含日期时间）
3. **前端通知**：成功通知只显示一次，并伴有简短提示音
4. **文件下载**：下载的文件使用实际生成的文件名

### 技术细节
- 向后兼容：不影响现有任务的处理
- 错误处理：音效播放失败不影响主要功能
- 用户体验：更清晰的输出组织和更好的反馈

## 风险与缓解

### 风险1：路径权限问题
- **风险**：新输出目录可能没有写入权限
- **缓解**：在 `lifespan` 函数中创建目录，确保权限正确

### 风险2：文件名冲突
- **风险**：同一秒内多个任务可能产生相同文件名
- **缓解**：文件名包含任务ID确保唯一性：`video_{task_id}_{timestamp}.mp4`

### 风险3：浏览器音效支持
- **风险**：某些浏览器可能不支持 `AudioContext`
- **缓解**：使用 `try-catch` 静默失败，不影响主要功能

### 风险4：前端兼容性
- **风险**：Vue/Element Plus 版本兼容性问题
- **缓解**：保持现有框架版本不变，只添加功能