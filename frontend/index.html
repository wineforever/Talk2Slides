<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Talk2Slides - 语义对齐视频生成</title>
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css" />
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/element-plus"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <style>
        :root {
            --ios-blue: #0a84ff;
            --ios-teal: #34c7f3;
            --ios-ink: #1e2633;
            --ios-muted: #556071;
            --ios-border: rgba(255, 255, 255, 0.58);
            --ios-card: rgba(255, 255, 255, 0.66);
            --ios-card-strong: rgba(255, 255, 255, 0.84);
            --ios-shadow: 0 24px 48px rgba(24, 44, 77, 0.15);
            --ios-soft-shadow: 0 10px 24px rgba(36, 61, 98, 0.12);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            position: relative;
            min-height: 100vh;
            padding: 24px;
            overflow-x: hidden;
            color: var(--ios-ink);
            font-family: "SF Pro Display", "SF Pro Text", "PingFang SC", "Helvetica Neue", "Segoe UI", sans-serif;
            background:
                radial-gradient(1200px 520px at -8% -18%, rgba(83, 148, 255, 0.34), rgba(83, 148, 255, 0) 62%),
                radial-gradient(760px 420px at 108% 4%, rgba(84, 207, 197, 0.28), rgba(84, 207, 197, 0) 70%),
                linear-gradient(160deg, #edf2fb 0%, #dce6f3 40%, #eef3fb 100%);
        }

        body::before,
        body::after {
            content: "";
            position: fixed;
            border-radius: 50%;
            filter: blur(10px);
            pointer-events: none;
            z-index: 0;
        }

        body::before {
            width: 420px;
            height: 420px;
            left: -110px;
            top: 18vh;
            background: radial-gradient(circle, rgba(89, 171, 255, 0.46) 0%, rgba(89, 171, 255, 0) 72%);
            animation: floatA 11s ease-in-out infinite;
        }

        body::after {
            width: 320px;
            height: 320px;
            right: -88px;
            top: 58vh;
            background: radial-gradient(circle, rgba(66, 215, 198, 0.38) 0%, rgba(66, 215, 198, 0) 72%);
            animation: floatB 12s ease-in-out infinite;
        }

        #app {
            position: relative;
            z-index: 1;
            animation: fadeIn 0.55s ease-out both;
        }

        .container {
            max-width: 1240px;
            margin: 0 auto;
            padding: 30px;
            border-radius: 32px;
            border: 1px solid var(--ios-border);
            background: var(--ios-card);
            box-shadow: var(--ios-shadow);
            backdrop-filter: blur(22px) saturate(150%);
            -webkit-backdrop-filter: blur(22px) saturate(150%);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: clamp(30px, 4.1vw, 44px);
            letter-spacing: -0.04em;
            font-weight: 760;
            color: #0f1929;
            margin-bottom: 6px;
            text-shadow: 0 4px 16px rgba(255, 255, 255, 0.48);
        }

        .header p {
            font-size: 14px;
            color: var(--ios-muted);
            letter-spacing: 0.01em;
        }

        .section-title {
            margin-bottom: 14px;
            font-size: 20px;
            font-weight: 700;
            letter-spacing: -0.02em;
            color: #111b2b;
        }

        .upload-section,
        .params-section,
        .result-section {
            margin-bottom: 20px;
            padding: 18px;
            border-radius: 24px;
            border: 1px solid var(--ios-border);
            background: var(--ios-card);
            box-shadow: var(--ios-soft-shadow);
            backdrop-filter: blur(14px) saturate(160%);
            -webkit-backdrop-filter: blur(14px) saturate(160%);
        }

        .upload-grid,
        .params-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 14px;
        }

        .upload-card,
        .param-item {
            border: 1px solid rgba(255, 255, 255, 0.7);
            background: var(--ios-card-strong);
            border-radius: 18px;
            padding: 14px;
            transition: transform 0.22s ease, box-shadow 0.22s ease;
        }

        .upload-card:hover,
        .param-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 26px rgba(52, 91, 148, 0.14);
        }

        .upload-card h3,
        .param-item h3 {
            font-size: 15px;
            font-weight: 650;
            letter-spacing: -0.01em;
            margin-bottom: 8px;
            color: #1b2433;
        }

        .tip {
            font-size: 12px;
            line-height: 1.45;
            color: #617085;
            margin-bottom: 10px;
        }

        .el-upload-dragger {
            border: 1px dashed rgba(78, 129, 205, 0.35) !important;
            border-radius: 16px !important;
            background: linear-gradient(160deg, rgba(255, 255, 255, 0.88), rgba(239, 245, 255, 0.86)) !important;
            transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease !important;
        }

        .el-upload-dragger:hover {
            transform: translateY(-1px);
            border-color: rgba(10, 132, 255, 0.6) !important;
            box-shadow: 0 8px 20px rgba(10, 132, 255, 0.14);
        }

        .file-list { margin-top: 10px; }

        .file-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            margin-bottom: 6px;
            padding: 7px 10px;
            border-radius: 12px;
            color: #243243;
            background: rgba(230, 238, 250, 0.88);
            border: 1px solid rgba(199, 214, 236, 0.8);
        }

        .file-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .remove-btn {
            color: #d63540;
            font-weight: 700;
            cursor: pointer;
            user-select: none;
        }

        .actions {
            text-align: center;
            margin: 26px 0;
        }

        .process-btn {
            border: none;
            min-width: 220px;
            padding: 14px 34px;
            border-radius: 999px;
            color: #fff;
            cursor: pointer;
            font-size: 17px;
            font-weight: 700;
            letter-spacing: 0.01em;
            background: linear-gradient(98deg, var(--ios-blue) 0%, var(--ios-teal) 100%);
            box-shadow:
                0 14px 24px rgba(10, 132, 255, 0.28),
                inset 0 1px 0 rgba(255, 255, 255, 0.48);
            transition: transform 0.2s ease, box-shadow 0.2s ease, filter 0.2s ease;
        }

        .process-btn:hover:not(:disabled) {
            transform: translateY(-1px) scale(1.01);
            box-shadow:
                0 16px 28px rgba(10, 132, 255, 0.32),
                inset 0 1px 0 rgba(255, 255, 255, 0.48);
            filter: saturate(1.04);
        }

        .process-btn:disabled {
            cursor: not-allowed;
            background: linear-gradient(96deg, #9eb2c7 0%, #8ea2b8 100%);
            box-shadow: none;
        }

        .video-preview {
            max-width: 860px;
            margin: 0 auto;
            border-radius: 20px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.74);
            box-shadow: 0 14px 36px rgba(25, 47, 80, 0.2);
            background: #fff;
        }

        .video-preview video {
            display: block;
        }

        .playback-progress-wrap {
            max-width: 860px;
            margin: 14px auto 0;
        }

        .playback-track {
            position: relative;
            height: 16px;
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.74);
            background: rgba(177, 194, 219, 0.44);
        }

        .playback-segments {
            display: flex;
            width: 100%;
            height: 100%;
        }

        .playback-segment {
            height: 100%;
            border-right: 1px solid rgba(255, 255, 255, 0.58);
            background: rgba(108, 135, 174, 0.3);
        }

        .playback-segment:last-child { border-right: none; }

        .playback-fill {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            background: linear-gradient(90deg, rgba(10, 132, 255, 0.66), rgba(52, 199, 243, 0.7));
            transition: width 0.12s linear;
            pointer-events: none;
        }

        .playback-thumb {
            position: absolute;
            top: -2px;
            bottom: -2px;
            width: 2px;
            background: rgba(19, 33, 54, 0.9);
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.75);
            transform: translateX(-1px);
            pointer-events: none;
        }

        .playback-label-row {
            display: flex;
            margin-top: 8px;
            overflow: hidden;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.72);
            background: rgba(244, 248, 255, 0.84);
        }

        .playback-label-item {
            padding: 4px 6px;
            font-size: 11px;
            color: #5a697f;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            border-right: 1px solid rgba(202, 214, 234, 0.72);
        }

        .playback-label-item:last-child { border-right: none; }

        .playback-label-item.active {
            color: #13213a;
            font-weight: 700;
            background: rgba(10, 132, 255, 0.14);
        }

        .playback-time {
            margin-top: 6px;
            text-align: right;
            color: #5f6f86;
            font-size: 12px;
        }

        .download-wrap { margin-top: 14px; text-align: center; }

        .download-btn {
            border: none;
            border-radius: 999px;
            padding: 11px 25px;
            color: #fff;
            cursor: pointer;
            font-size: 15px;
            font-weight: 700;
            letter-spacing: 0.01em;
            background: linear-gradient(98deg, #178fff 0%, #15b4ff 100%);
            box-shadow:
                0 12px 24px rgba(22, 133, 255, 0.25),
                inset 0 1px 0 rgba(255, 255, 255, 0.48);
        }

        .quality-section {
            margin-top: 16px;
            padding: 12px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.74);
            background: rgba(255, 255, 255, 0.8);
        }

        .quality-title {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 10px;
            color: #172537;
        }

        .quality-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 10px;
        }

        .quality-item {
            padding: 8px;
            border-radius: 12px;
            border: 1px solid rgba(205, 218, 238, 0.78);
            background: rgba(242, 247, 255, 0.92);
        }

        .quality-item .label {
            margin-bottom: 4px;
            font-size: 12px;
            color: #60708a;
        }

        .quality-item .value {
            font-size: 14px;
            font-weight: 700;
            color: #1a2738;
        }

        .el-collapse,
        .el-collapse-item__wrap,
        .el-collapse-item__header {
            border: none !important;
            background: transparent !important;
        }

        .el-collapse-item__header {
            padding: 0 6px !important;
            color: #1d2a3d !important;
            font-weight: 650 !important;
        }

        .el-slider__runway {
            background: rgba(178, 194, 221, 0.48) !important;
            height: 8px !important;
        }

        .el-slider__bar {
            background: linear-gradient(90deg, var(--ios-blue), var(--ios-teal)) !important;
            height: 8px !important;
        }

        .el-slider__button {
            width: 18px !important;
            height: 18px !important;
            border: 3px solid #fff !important;
            background: linear-gradient(180deg, #34b6ff, #0a84ff) !important;
            box-shadow: 0 2px 8px rgba(16, 86, 178, 0.28) !important;
        }

        .el-select__wrapper {
            border-radius: 12px !important;
            border: 1px solid rgba(206, 218, 236, 0.84) !important;
            background: rgba(255, 255, 255, 0.88) !important;
            box-shadow: none !important;
        }

        .el-checkbox__input.is-checked .el-checkbox__inner {
            background-color: var(--ios-blue) !important;
            border-color: var(--ios-blue) !important;
        }

        .footer {
            margin-top: 10px;
            text-align: center;
            font-size: 12px;
            color: #70829b;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes floatA {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-14px); }
        }

        @keyframes floatB {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(14px); }
        }

        @media (max-width: 980px) {
            body { padding: 12px; }
            .container {
                padding: 18px;
                border-radius: 22px;
            }
            .upload-section,
            .params-section,
            .result-section {
                border-radius: 18px;
            }
        }

        @media (max-width: 640px) {
            .header h1 { font-size: 30px; }
            .section-title { font-size: 18px; }
            .process-btn {
                width: 100%;
                min-width: 0;
            }
        }
    </style>
</head>
<body>
<div id="app">
    <div class="container">
        <div class="header">
            <h1>Talk2Slides</h1>
            <p>上传 PPTX + 音频 + SRT，自动生成按语义切页的视频</p>
        </div>

        <div class="upload-section">
            <div class="section-title">文件上传</div>
            <div class="upload-grid">
                <div class="upload-card">
                    <h3>PPTX 文件</h3>
                    <el-upload drag :auto-upload="false" :on-change="handlePPTXChange" :show-file-list="false" accept=".pptx">
                        <i class="el-icon-upload"></i>
                        <div class="el-upload__text">拖拽到此处，或点击上传</div>
                    </el-upload>
                    <div class="file-list" v-if="pptxFiles.length">
                        <div class="file-item" v-for="file in pptxFiles" :key="file.name + file.size">
                            <span class="file-name">{{ file.name }}</span>
                            <span>{{ formatFileSize(file.size) }}</span>
                            <span class="remove-btn" @click="removeFile('pptx', file)">×</span>
                        </div>
                    </div>
                </div>

                <div class="upload-card">
                    <h3>音频文件（MP3/WAV）</h3>
                    <el-upload drag :auto-upload="false" :on-change="handleMP3Change" :show-file-list="false" accept=".mp3,.wav,.wave">
                        <i class="el-icon-upload"></i>
                        <div class="el-upload__text">拖拽到此处，或点击上传</div>
                    </el-upload>
                    <div class="file-list" v-if="mp3Files.length">
                        <div class="file-item" v-for="file in mp3Files" :key="file.name + file.size">
                            <span class="file-name">{{ file.name }}</span>
                            <span>{{ formatFileSize(file.size) }}</span>
                            <span class="remove-btn" @click="removeFile('mp3', file)">×</span>
                        </div>
                    </div>
                </div>

                <div class="upload-card">
                    <h3>SRT 字幕</h3>
                    <el-upload drag :auto-upload="false" :on-change="handleSRTChange" :show-file-list="false" accept=".srt">
                        <i class="el-icon-upload"></i>
                        <div class="el-upload__text">拖拽到此处，或点击上传</div>
                    </el-upload>
                    <div class="file-list" v-if="srtFiles.length">
                        <div class="file-item" v-for="file in srtFiles" :key="file.name + file.size">
                            <span class="file-name">{{ file.name }}</span>
                            <span>{{ formatFileSize(file.size) }}</span>
                            <span class="remove-btn" @click="removeFile('srt', file)">×</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="params-section">
            <div class="section-title">处理参数</div>
            <div class="params-grid">
                <div class="param-item">
                    <h3>相似度阈值</h3>
                    <p class="tip">字幕与页面的最低匹配阈值</p>
                    <el-slider v-model="similarityThreshold" :min="0" :max="1" :step="0.05" show-input></el-slider>
                </div>
                <div class="param-item">
                    <h3>最短展示时长（秒）</h3>
                    <p class="tip">每个页面至少展示多久</p>
                    <el-slider v-model="minDisplayDuration" :min="1" :max="10" :step="0.5" show-input></el-slider>
                </div>
                <div class="param-item">
                    <h3>输出分辨率</h3>
                    <p class="tip">视频输出尺寸</p>
                    <el-select v-model="outputResolution" style="width: 100%;">
                        <el-option label="1920x1080 (Full HD)" value="1920x1080"></el-option>
                        <el-option label="1280x720 (HD)" value="1280x720"></el-option>
                        <el-option label="1024x576" value="1024x576"></el-option>
                    </el-select>
                </div>
            </div>

            <el-collapse v-model="advancedParamsOpen" style="margin-top: 12px;">
                <el-collapse-item title="高级参数" name="advanced">
                    <div class="params-grid">
                        <div class="param-item">
                            <h3>字幕合并间隔（秒）</h3>
                            <p class="tip">间隔小于该值时会合并字幕块</p>
                            <el-slider v-model="srtMergeGapSec" :min="0.2" :max="2.0" :step="0.1" show-input></el-slider>
                        </div>
                        <div class="param-item">
                            <h3>字幕最短时长（秒）</h3>
                            <p class="tip">过滤过短片段，减少过密切页</p>
                            <el-slider v-model="srtMinDurationSec" :min="0.5" :max="3.0" :step="0.1" show-input></el-slider>
                        </div>
                        <div class="param-item">
                            <h3>最大前跳页数</h3>
                            <p class="tip">每次最多允许向后跳过几页</p>
                            <el-slider v-model="alignMaxForwardJump" :min="0" :max="5" :step="1" show-input></el-slider>
                        </div>
                        <div class="param-item">
                            <h3>最大回退页数</h3>
                            <p class="tip">每次最多允许向前回退几页</p>
                            <el-slider v-model="alignMaxBacktrack" :min="0" :max="3" :step="1" show-input></el-slider>
                        </div>
                        <div class="param-item">
                            <h3>切换惩罚</h3>
                            <p class="tip">提高可减少过早切页</p>
                            <el-slider v-model="alignSwitchPenalty" :min="0" :max="0.5" :step="0.01" show-input></el-slider>
                        </div>
                        <div class="param-item">
                            <h3>前跳惩罚</h3>
                            <p class="tip">提高可抑制提前跳到后面页</p>
                            <el-slider v-model="alignForwardJumpPenalty" :min="0" :max="0.2" :step="0.01" show-input></el-slider>
                        </div>
                        <div class="param-item">
                            <h3>切页延迟（毫秒）</h3>
                            <p class="tip">切页时间向后偏移，减少“抢话”</p>
                            <el-slider v-model="alignSwitchDelayMs" :min="0" :max="1000" :step="50" show-input></el-slider>
                        </div>
                        <div class="param-item">
                            <h3>禁止回访已讲页</h3>
                            <p class="tip">允许乱序，但不允许回到已经讲过的页</p>
                            <el-checkbox v-model="alignEnforceNoRevisit">启用</el-checkbox>
                        </div>
                        <div class="param-item">
                            <h3>最少页面覆盖率</h3>
                            <p class="tip">希望至少覆盖多少比例的页面</p>
                            <el-slider v-model="alignMinSlideUsageRatio" :min="0.5" :max="1.0" :step="0.05" show-input></el-slider>
                        </div>
                        <div class="param-item">
                            <h3>结构先验权重</h3>
                            <p class="tip">按首页/目录/章节/结束页结构增强对齐（0 为关闭）</p>
                            <el-slider v-model="alignStructurePriorWeight" :min="0" :max="0.35" :step="0.01" show-input></el-slider>
                        </div>
                        <div class="param-item">
                            <h3>禁止跳页（顺序讲每页）</h3>
                            <p class="tip">可选项，默认不勾选</p>
                            <el-checkbox v-model="alignEnforceSequential">启用</el-checkbox>
                        </div>
                        <div class="param-item">
                            <h3>嵌入视频进度条</h3>
                            <p class="tip">将结构化进度条直接渲染到视频底部画面</p>
                            <el-checkbox v-model="embedProgressBar">启用（默认）</el-checkbox>
                        </div>
                        <div class="param-item">
                            <h3>进度条分段上限</h3>
                            <p class="tip">分段过多时自动合并短段，避免过密</p>
                            <el-slider v-model="progressMaxSegments" :min="2" :max="30" :step="1" show-input></el-slider>
                        </div>
                        <div class="param-item">
                            <h3>文案最大字数</h3>
                            <p class="tip">每段文字超出后自动以 ... 缩略</p>
                            <el-slider v-model="progressLabelMaxChars" :min="3" :max="20" :step="1" show-input></el-slider>
                        </div>
                        <div class="param-item">
                            <h3>SRT 字幕压制</h3>
                            <p class="tip">将上传的 SRT 字幕直接压制到导出视频画面</p>
                            <el-checkbox v-model="burnSrtSubtitles">启用（默认）</el-checkbox>
                        </div>
                    </div>
                </el-collapse-item>
            </el-collapse>
        </div>

        <div class="actions">
            <button class="process-btn" @click="startProcessing" :disabled="processing || !filesReady">
                {{ processing ? '处理中...' : '开始生成视频' }}
            </button>
        </div>

        <div v-if="resultVideoUrl" class="result-section">
            <div class="section-title">生成结果</div>
            <div class="video-preview">
                <video
                    ref="resultVideoEl"
                    :src="resultVideoUrl"
                    controls
                    width="100%"
                    @loadedmetadata="onVideoLoadedMetadata"
                    @timeupdate="onVideoTimeUpdate"
                    @seeked="onVideoTimeUpdate"
                ></video>
            </div>
            <div class="download-wrap">
                <a :href="resultVideoUrl" :download="resultVideoFilename">
                    <button class="download-btn">下载视频</button>
                </a>
            </div>

            <div class="quality-section">
                <div class="quality-title">处理耗时</div>
                <div class="quality-grid">
                    <div class="quality-item">
                        <div class="label">总耗时</div>
                        <div class="value">{{ totalProcessingDurationText }}</div>
                    </div>
                </div>
            </div>

            <div v-if="alignmentReport && alignmentReport.summary" class="quality-section">
                <div class="quality-title">对齐质量报告</div>
                <div class="quality-grid">
                    <div class="quality-item">
                        <div class="label">质量评级</div>
                        <div class="value">{{ alignmentReport.summary.grade }} ({{ alignmentReport.summary.health_score }})</div>
                    </div>
                    <div class="quality-item">
                        <div class="label">页面覆盖率</div>
                        <div class="value">{{ alignmentReport.summary.unique_slides_used }}/{{ alignmentReport.summary.total_slides || '-' }} ({{ formatPercent(alignmentReport.summary.slide_coverage_ratio) }})</div>
                    </div>
                    <div class="quality-item">
                        <div class="label">低置信比例</div>
                        <div class="value">{{ formatPercent(alignmentReport.confidence && alignmentReport.confidence.low_confidence_ratio) }}</div>
                    </div>
                    <div class="quality-item">
                        <div class="label">可疑边界</div>
                        <div class="value">{{ (alignmentReport.boundary_quality && alignmentReport.boundary_quality.suspicious_count) || 0 }} ({{ formatPercent(alignmentReport.boundary_quality && alignmentReport.boundary_quality.suspicious_ratio) }})</div>
                    </div>
                    <div class="quality-item">
                        <div class="label">回访违规次数</div>
                        <div class="value">{{ (alignmentReport.transition_stats && alignmentReport.transition_stats.revisit_violations) || 0 }}</div>
                    </div>
                    <div class="quality-item">
                        <div class="label">策略参数</div>
                        <div class="value">
                            no_revisit={{ (alignmentReport.coverage_policy && alignmentReport.coverage_policy.enforce_no_revisit) ? 'on' : 'off' }},
                            min_usage={{ formatPercent(alignmentReport.coverage_policy && alignmentReport.coverage_policy.min_slide_usage_ratio) }},
                            structure_w={{ (alignmentReport.scoring && alignmentReport.scoring.weights) ? Number(alignmentReport.scoring.weights.structure || 0).toFixed(2) : '0.00' }}
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="footer">Talk2Slides &copy; 2026</div>
    </div>
</div>

<script>
const { createApp, ref, computed, onMounted } = Vue;
const { ElMessage } = ElementPlus;

createApp({
    setup() {
        const pptxFiles = ref([]);
        const mp3Files = ref([]);
        const srtFiles = ref([]);

        const similarityThreshold = ref(0.5);
        const minDisplayDuration = ref(2.0);
        const outputResolution = ref('1920x1080');
        const embedProgressBar = ref(true);
        const burnSrtSubtitles = ref(true);
        const progressMaxSegments = ref(10);
        const progressLabelMaxChars = ref(10);
        const srtMergeGapSec = ref(0.6);
        const srtMinDurationSec = ref(0.8);
        const alignMaxForwardJump = ref(5);
        const alignMaxBacktrack = ref(2);
        const alignSwitchPenalty = ref(0.08);
        const alignForwardJumpPenalty = ref(0.03);
        const alignSwitchDelayMs = ref(250);
        const alignEnforceNoRevisit = ref(true);
        const alignMinSlideUsageRatio = ref(0.70);
        const alignStructurePriorWeight = ref(0.16);
        const alignEnforceSequential = ref(false);
        const advancedParamsOpen = ref([]);

        const processing = ref(false);
        const progress = ref(0);
        const progressText = ref('');
        const elapsedText = ref('--:--');
        const etaText = ref('--:--');
        const totalProcessingDurationText = ref('--:--');
        const resultVideoUrl = ref('');
        const resultVideoFilename = ref('generated_video.mp4');
        const alignmentReport = ref(null);
        const resultVideoEl = ref(null);
        const timelineOverview = ref([]);
        const videoDurationSec = ref(0);
        const currentPlaybackSec = ref(0);
        const taskId = ref('');
        const hasShownSuccess = ref(false);

        let notificationAudio = null;

        const filesReady = computed(() => {
            return pptxFiles.value.length > 0 && mp3Files.value.length > 0 && srtFiles.value.length > 0;
        });

        const handlePPTXChange = (file) => { pptxFiles.value = [file.raw]; };
        const handleMP3Change = (file) => { mp3Files.value = [file.raw]; };
        const handleSRTChange = (file) => { srtFiles.value = [file.raw]; };

        const removeFile = (type, file) => {
            if (type === 'pptx') pptxFiles.value = pptxFiles.value.filter(f => f !== file);
            if (type === 'mp3') mp3Files.value = mp3Files.value.filter(f => f !== file);
            if (type === 'srt') srtFiles.value = srtFiles.value.filter(f => f !== file);
        };

        const formatFileSize = (bytes) => {
            if (!bytes || bytes <= 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;
        };

        const formatDuration = (seconds) => {
            if (seconds === null || seconds === undefined || Number.isNaN(Number(seconds))) return '--:--';
            const total = Math.max(0, Math.round(Number(seconds)));
            const h = Math.floor(total / 3600);
            const m = Math.floor((total % 3600) / 60);
            const s = total % 60;
            if (h > 0) return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
            return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        };

        const formatPercent = (ratio) => {
            if (ratio === null || ratio === undefined || Number.isNaN(Number(ratio))) return '--';
            return `${(Number(ratio) * 100).toFixed(1)}%`;
        };

        const toNumberOr = (value, fallback) => {
            const num = Number(value);
            return Number.isFinite(num) ? num : fallback;
        };

        const toBoolOr = (value, fallback) => {
            if (typeof value === 'boolean') return value;
            if (typeof value === 'string') {
                const normalized = value.trim().toLowerCase();
                if (['1', 'true', 'yes', 'y', 'on'].includes(normalized)) return true;
                if (['0', 'false', 'no', 'n', 'off'].includes(normalized)) return false;
            }
            return fallback;
        };

        const loadDefaultsFromServer = async () => {
            try {
                const { data } = await axios.get('/api/defaults');
                if (!data || typeof data !== 'object') return;

                similarityThreshold.value = toNumberOr(data.similarity_threshold, similarityThreshold.value);
                minDisplayDuration.value = toNumberOr(data.min_display_duration, minDisplayDuration.value);
                outputResolution.value = (typeof data.output_resolution === 'string' && data.output_resolution.trim())
                    ? data.output_resolution.trim()
                    : outputResolution.value;
                embedProgressBar.value = toBoolOr(data.embed_progress_bar, embedProgressBar.value);
                burnSrtSubtitles.value = toBoolOr(data.burn_srt_subtitles, burnSrtSubtitles.value);
                progressMaxSegments.value = toNumberOr(data.progress_max_segments, progressMaxSegments.value);
                progressLabelMaxChars.value = toNumberOr(data.progress_label_max_chars, progressLabelMaxChars.value);
                srtMergeGapSec.value = toNumberOr(data.srt_merge_gap_sec, srtMergeGapSec.value);
                srtMinDurationSec.value = toNumberOr(data.srt_min_duration_sec, srtMinDurationSec.value);
                alignMaxBacktrack.value = toNumberOr(data.align_max_backtrack, alignMaxBacktrack.value);
                alignMaxForwardJump.value = toNumberOr(data.align_max_forward_jump, alignMaxForwardJump.value);
                alignSwitchPenalty.value = toNumberOr(data.align_switch_penalty, alignSwitchPenalty.value);
                alignForwardJumpPenalty.value = toNumberOr(data.align_forward_jump_penalty, alignForwardJumpPenalty.value);
                alignSwitchDelayMs.value = toNumberOr(data.align_switch_delay_ms, alignSwitchDelayMs.value);
                alignEnforceNoRevisit.value = toBoolOr(data.align_enforce_no_revisit, alignEnforceNoRevisit.value);
                alignMinSlideUsageRatio.value = toNumberOr(data.align_min_slide_usage_ratio, alignMinSlideUsageRatio.value);
                alignStructurePriorWeight.value = toNumberOr(data.align_structure_prior_weight, alignStructurePriorWeight.value);
                alignEnforceSequential.value = toBoolOr(data.align_enforce_sequential, alignEnforceSequential.value);
            } catch (err) {
                console.warn('Failed to load defaults from /api/defaults:', err);
            }
        };

        onMounted(async () => {
            notificationAudio = new Audio('/api/sound');
            notificationAudio.preload = 'auto';
            await loadDefaultsFromServer();
        });

        const normalizeTimelineOverview = (items) => {
            const normalized = (Array.isArray(items) ? items : [])
                .map((item, idx) => {
                    const start = Number(item?.start ?? 0);
                    const end = Number(item?.end ?? start);
                    const slideIndexNumber = Number(item?.slide_index);
                    const slideIndex = Number.isFinite(slideIndexNumber) ? slideIndexNumber : -1;
                    const rawLabel = String(item?.label || '').trim();
                    const fallbackLabel = slideIndex >= 0 ? `第${slideIndex + 1}页` : `片段${idx + 1}`;
                    return {
                        start: Number.isFinite(start) ? Math.max(0, start) : 0,
                        end: Number.isFinite(end) ? Math.max(0, end) : 0,
                        slide_index: slideIndex,
                        label: rawLabel || fallbackLabel,
                    };
                })
                .filter(item => item.end > item.start)
                .sort((a, b) => a.start - b.start);

            const merged = [];
            normalized.forEach(item => {
                const last = merged.length ? merged[merged.length - 1] : null;
                if (
                    last &&
                    item.slide_index === last.slide_index &&
                    item.label === last.label &&
                    item.start <= last.end + 0.05
                ) {
                    last.end = Math.max(last.end, item.end);
                    return;
                }
                merged.push({ ...item });
            });
            return merged;
        };

        const buildTimelineOverviewFallback = (timeline) => {
            const fallback = (Array.isArray(timeline) ? timeline : []).map((item, idx) => {
                const slideIndexNumber = Number(item?.slide_index);
                const slideIndex = Number.isFinite(slideIndexNumber) ? slideIndexNumber : -1;
                return {
                    start: Number(item?.start ?? 0),
                    end: Number(item?.end ?? item?.start ?? 0),
                    slide_index: slideIndex,
                    label: slideIndex >= 0 ? `第${slideIndex + 1}页` : `片段${idx + 1}`,
                };
            });
            return normalizeTimelineOverview(fallback);
        };

        const playbackTotalDuration = computed(() => {
            const timelineEnd = timelineOverview.value.length
                ? Number(timelineOverview.value[timelineOverview.value.length - 1].end)
                : 0;
            return Math.max(Number(videoDurationSec.value) || 0, timelineEnd || 0);
        });

        const segmentBars = computed(() => {
            const total = playbackTotalDuration.value;
            if (total <= 0 || !timelineOverview.value.length) return [];
            return timelineOverview.value
                .map((seg, idx) => {
                    const duration = Math.max(0, Number(seg.end) - Number(seg.start));
                    return {
                        ...seg,
                        widthPct: Math.max(0, (duration / total) * 100),
                        key: `${idx}-${Number(seg.start).toFixed(3)}-${Number(seg.end).toFixed(3)}-${seg.slide_index}`,
                    };
                })
                .filter(seg => seg.widthPct > 0);
        });

        const playbackPercent = computed(() => {
            const total = playbackTotalDuration.value;
            if (total <= 0) return 0;
            return Math.min(100, Math.max(0, (Number(currentPlaybackSec.value) / total) * 100));
        });

        const activeSegmentIndex = computed(() => {
            const segments = segmentBars.value;
            if (!segments.length) return -1;
            const current = Number(currentPlaybackSec.value) || 0;
            for (let i = 0; i < segments.length; i += 1) {
                if (current >= Number(segments[i].start) && current < Number(segments[i].end)) {
                    return i;
                }
            }
            if (current >= Number(segments[segments.length - 1].end)) {
                return segments.length - 1;
            }
            return 0;
        });

        const onVideoLoadedMetadata = (event) => {
            const video = event?.target || resultVideoEl.value;
            const duration = Number(video?.duration || 0);
            if (Number.isFinite(duration) && duration > 0) videoDurationSec.value = duration;
            currentPlaybackSec.value = Number(video?.currentTime || 0);
        };

        const onVideoTimeUpdate = (event) => {
            const video = event?.target || resultVideoEl.value;
            currentPlaybackSec.value = Number(video?.currentTime || 0);
            const duration = Number(video?.duration || 0);
            if (Number.isFinite(duration) && duration > 0) videoDurationSec.value = duration;
        };

        const playNotificationSound = () => {
            try {
                if (!notificationAudio) {
                    notificationAudio = new Audio('/api/sound');
                    notificationAudio.preload = 'auto';
                }
                notificationAudio.currentTime = 0;
                notificationAudio.play().catch(() => {});
            } catch (_) {}
        };

        const startProcessing = async () => {
            if (!filesReady.value) {
                ElMessage.error('请上传全部必需文件');
                return;
            }

            processing.value = true;
            progress.value = 0;
            progressText.value = 'Preparing upload...';
            elapsedText.value = '00:00';
            etaText.value = '--:--';
            totalProcessingDurationText.value = '--:--';
            resultVideoUrl.value = '';
            resultVideoFilename.value = 'generated_video.mp4';
            alignmentReport.value = null;
            timelineOverview.value = [];
            videoDurationSec.value = 0;
            currentPlaybackSec.value = 0;
            hasShownSuccess.value = false;

            const formData = new FormData();
            formData.append('pptx', pptxFiles.value[0]);
            formData.append('mp3', mp3Files.value[0]);
            formData.append('srt', srtFiles.value[0]);
            formData.append('similarity_threshold', similarityThreshold.value);
            formData.append('min_display_duration', minDisplayDuration.value);
            formData.append('output_resolution', outputResolution.value);
            formData.append('embed_progress_bar', embedProgressBar.value);
            formData.append('burn_srt_subtitles', burnSrtSubtitles.value);
            formData.append('progress_max_segments', progressMaxSegments.value);
            formData.append('progress_label_max_chars', progressLabelMaxChars.value);
            formData.append('srt_merge_gap_sec', srtMergeGapSec.value);
            formData.append('srt_min_duration_sec', srtMinDurationSec.value);
            formData.append('align_max_forward_jump', alignMaxForwardJump.value);
            formData.append('align_max_backtrack', alignMaxBacktrack.value);
            formData.append('align_switch_penalty', alignSwitchPenalty.value);
            formData.append('align_forward_jump_penalty', alignForwardJumpPenalty.value);
            formData.append('align_switch_delay_ms', alignSwitchDelayMs.value);
            formData.append('align_enforce_no_revisit', alignEnforceNoRevisit.value);
            formData.append('align_min_slide_usage_ratio', alignMinSlideUsageRatio.value);
            formData.append('align_structure_prior_weight', alignStructurePriorWeight.value);
            formData.append('align_enforce_sequential', alignEnforceSequential.value);

            try {
                const uploadResponse = await axios.post('/api/upload', formData, {
                    headers: { 'Content-Type': 'multipart/form-data' },
                    onUploadProgress: (e) => {
                        const percent = e.total ? Math.round((e.loaded * 100) / e.total) : 0;
                        progress.value = percent * 0.3;
                        progressText.value = `Uploading files... ${percent}%`;
                    }
                });

                taskId.value = uploadResponse.data.task_id;
                progress.value = 30;
                progressText.value = 'Upload completed. Processing started...';

                const pollInterval = setInterval(async () => {
                    try {
                        const { data: status } = await axios.get(`/api/task/${taskId.value}/status`);
                        progress.value = 30 + Math.floor(status.progress * 0.7);
                        progressText.value = status.message || 'Processing...';
                        elapsedText.value = formatDuration(status.elapsed_seconds);
                        const statusDurationSeconds = status.processing_duration_seconds ?? status.elapsed_seconds;
                        if (status.processing_duration_formatted) totalProcessingDurationText.value = status.processing_duration_formatted;
                        else totalProcessingDurationText.value = formatDuration(statusDurationSeconds);
                        if (status.eta_formatted) etaText.value = status.eta_formatted;
                        else if (status.state === 'completed') etaText.value = '00:00';
                        else if (status.state === 'processing') etaText.value = 'calculating...';
                        else etaText.value = '--:--';

                        if (status.state === 'completed' && !hasShownSuccess.value) {
                            hasShownSuccess.value = true;
                            clearInterval(pollInterval);
                            progress.value = 100;
                            progressText.value = 'Completed';
                            processing.value = false;

                            const { data: preview } = await axios.get(`/api/task/${taskId.value}/preview`);
                            resultVideoUrl.value = preview.video_url;
                            resultVideoFilename.value = preview.filename;
                            alignmentReport.value = preview.alignment_report || null;
                            timelineOverview.value = (Array.isArray(preview.timeline_overview) && preview.timeline_overview.length)
                                ? normalizeTimelineOverview(preview.timeline_overview)
                                : buildTimelineOverviewFallback(preview.timeline);
                            if (preview.processing_duration_formatted) totalProcessingDurationText.value = preview.processing_duration_formatted;
                            else totalProcessingDurationText.value = formatDuration(preview.processing_duration_seconds ?? statusDurationSeconds);
                            videoDurationSec.value = 0;
                            currentPlaybackSec.value = 0;

                            ElMessage.success('视频生成成功');
                            playNotificationSound();
                        } else if (status.state === 'failed') {
                            clearInterval(pollInterval);
                            processing.value = false;
                            etaText.value = '--:--';
                            ElMessage.error(`处理失败: ${status.error}`);
                        }
                    } catch (err) {
                        console.error('Polling error:', err);
                    }
                }, 1000);
            } catch (err) {
                processing.value = false;
                ElMessage.error('上传失败: ' + (err.response?.data?.detail || err.message));
            }
        };

        return {
            pptxFiles,
            mp3Files,
            srtFiles,
            similarityThreshold,
            minDisplayDuration,
            outputResolution,
            embedProgressBar,
            burnSrtSubtitles,
            progressMaxSegments,
            progressLabelMaxChars,
            srtMergeGapSec,
            srtMinDurationSec,
            alignMaxForwardJump,
            alignMaxBacktrack,
            alignSwitchPenalty,
            alignForwardJumpPenalty,
            alignSwitchDelayMs,
            alignEnforceNoRevisit,
            alignMinSlideUsageRatio,
            alignStructurePriorWeight,
            alignEnforceSequential,
            advancedParamsOpen,
            processing,
            progress,
            progressText,
            elapsedText,
            etaText,
            totalProcessingDurationText,
            resultVideoUrl,
            resultVideoFilename,
            alignmentReport,
            resultVideoEl,
            segmentBars,
            playbackPercent,
            activeSegmentIndex,
            currentPlaybackSec,
            videoDurationSec,
            filesReady,
            handlePPTXChange,
            handleMP3Change,
            handleSRTChange,
            removeFile,
            formatFileSize,
            formatDuration,
            formatPercent,
            onVideoLoadedMetadata,
            onVideoTimeUpdate,
            startProcessing
        };
    }
}).use(ElementPlus).mount('#app');
</script>
</body>
</html>
